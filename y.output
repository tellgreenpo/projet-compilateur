Non-terminaux inutiles dans la grammaire

    args
    expr
    names
    divMul


Terminaux inutilisés dans la grammaire

    EOL
    DOT
    OPEN_BRACKET
    CLOSE_BRACKET
    PLUS
    MINUS
    MULTIPLY
    DIVIDE


Règles inutiles dans la grammaire

   43 args: value COMMA args
   44     | value
   45     | %empty

   46 expr: expr EQUAL expr
   47     | expr PLUS expr
   48     | expr MINUS expr
   49     | expr MULTIPLY expr
   50     | expr DIVIDE expr
   51     | name
   52     | value

   53 names: name COMMA names
   54      | name


Grammaire

    0 $accept: main_structure $end

    1 main_structure: type MAIN OPEN_PARENT params CLOSE_PARENT body

    2 body: OPEN_BRACE insts CLOSE_BRACE

    3 insts: inst insts
    4      | %empty

    5 inst: declaration
    6     | affectation
    7     | print
    8     | ifBlock
    9     | whileBlock
   10     | RETURN value SEMICOLON
   11     | RETURN name SEMICOLON

   12 params: type name COMMA params
   13       | type name
   14       | %empty

   15 declaration: type ids SEMICOLON

   16 affectation: type id EQUAL value SEMICOLON
   17            | name EQUAL value SEMICOLON

   18 print: PRINTF OPEN_PARENT value CLOSE_PARENT SEMICOLON
   19      | PRINTF OPEN_PARENT name CLOSE_PARENT SEMICOLON

   20 ifBlock: IF OPEN_PARENT condition CLOSE_PARENT body
   21        | ELSE IF OPEN_PARENT condition CLOSE_PARENT body
   22        | ELSE body

   23 whileBlock: WHILE OPEN_PARENT condition CLOSE_PARENT body

   24 condition: valueOrVar
   25          | unaryOperand valueOrVar
   26          | valueOrVar binaryOperand valueOrVar

   27 binaryOperand: LESS
   28              | LESS_EQ
   29              | MORE
   30              | MORE_EQ
   31              | EQUALITY
   32              | DIFF

   33 unaryOperand: EXCLAM

   34 value: NUMBER

   35 type: INT
   36     | CONST INT

   37 name: ALPHA

   38 valueOrVar: value
   39           | name

   40 id: ALPHA

   41 ids: id COMMA ids
   42    | id


Terminaux, suivis des règles où ils apparaissent

    $end (0) 0
    error (256)
    MAIN (258) 1
    RETURN (259) 10 11
    PRINTF (260) 18 19
    CONST (261) 36
    EOL (262)
    DOT (263)
    COMMA (264) 12 41
    SEMICOLON (265) 10 11 15 16 17 18 19
    OPEN_BRACE (266) 2
    CLOSE_BRACE (267) 2
    OPEN_BRACKET (268)
    CLOSE_BRACKET (269)
    OPEN_PARENT (270) 1 18 19 20 21 23
    CLOSE_PARENT (271) 1 18 19 20 21 23
    IF (272) 20 21
    ELSE (273) 21 22
    WHILE (274) 23
    EXCLAM (275) 33
    EQUALITY (276) 31
    DIFF (277) 32
    LESS (278) 27
    MORE (279) 29
    LESS_EQ (280) 28
    MORE_EQ (281) 30
    NUMBER <nb> (282) 34
    ALPHA <str> (283) 37 40
    INT <str> (284) 35 36
    EQUAL (285) 16 17
    PLUS (286)
    MINUS (287)
    MULTIPLY (288)
    DIVIDE (289)


Non-terminaux, suivis des règles où ils apparaissent

    $accept (35)
        à gauche: 0
    main_structure (36)
        à gauche: 1
        à droite: 0
    body (37)
        à gauche: 2
        à droite: 1 20 21 22 23
    insts (38)
        à gauche: 3 4
        à droite: 2 3
    inst (39)
        à gauche: 5 6 7 8 9 10 11
        à droite: 3
    params (40)
        à gauche: 12 13 14
        à droite: 1 12
    declaration (41)
        à gauche: 15
        à droite: 5
    affectation (42)
        à gauche: 16 17
        à droite: 6
    print (43)
        à gauche: 18 19
        à droite: 7
    ifBlock (44)
        à gauche: 20 21 22
        à droite: 8
    whileBlock (45)
        à gauche: 23
        à droite: 9
    condition (46)
        à gauche: 24 25 26
        à droite: 20 21 23
    binaryOperand (47)
        à gauche: 27 28 29 30 31 32
        à droite: 26
    unaryOperand (48)
        à gauche: 33
        à droite: 25
    value <nb> (49)
        à gauche: 34
        à droite: 10 16 17 18 38
    type <nb> (50)
        à gauche: 35 36
        à droite: 1 12 13 15 16
    name <str> (51)
        à gauche: 37
        à droite: 11 12 13 17 19 39
    valueOrVar (52)
        à gauche: 38 39
        à droite: 24 25 26
    id <str> (53)
        à gauche: 40
        à droite: 16 41 42
    ids (54)
        à gauche: 41 42
        à droite: 15 41


État 0

    0 $accept: . main_structure $end

    CONST  décalage et aller à l'état 1
    INT    décalage et aller à l'état 2

    main_structure  aller à l'état 3
    type            aller à l'état 4


État 1

   36 type: CONST . INT

    INT  décalage et aller à l'état 5


État 2

   35 type: INT .

    $défaut  réduction par utilisation de la règle 35 (type)


État 3

    0 $accept: main_structure . $end

    $end  décalage et aller à l'état 6


État 4

    1 main_structure: type . MAIN OPEN_PARENT params CLOSE_PARENT body

    MAIN  décalage et aller à l'état 7


État 5

   36 type: CONST INT .

    $défaut  réduction par utilisation de la règle 36 (type)


État 6

    0 $accept: main_structure $end .

    $défaut  accepter


État 7

    1 main_structure: type MAIN . OPEN_PARENT params CLOSE_PARENT body

    OPEN_PARENT  décalage et aller à l'état 8


État 8

    1 main_structure: type MAIN OPEN_PARENT . params CLOSE_PARENT body

    CONST  décalage et aller à l'état 1
    INT    décalage et aller à l'état 2

    $défaut  réduction par utilisation de la règle 14 (params)

    params  aller à l'état 9
    type    aller à l'état 10


État 9

    1 main_structure: type MAIN OPEN_PARENT params . CLOSE_PARENT body

    CLOSE_PARENT  décalage et aller à l'état 11


État 10

   12 params: type . name COMMA params
   13       | type . name

    ALPHA  décalage et aller à l'état 12

    name  aller à l'état 13


État 11

    1 main_structure: type MAIN OPEN_PARENT params CLOSE_PARENT . body

    OPEN_BRACE  décalage et aller à l'état 14

    body  aller à l'état 15


État 12

   37 name: ALPHA .

    $défaut  réduction par utilisation de la règle 37 (name)


État 13

   12 params: type name . COMMA params
   13       | type name .

    COMMA  décalage et aller à l'état 16

    $défaut  réduction par utilisation de la règle 13 (params)


État 14

    2 body: OPEN_BRACE . insts CLOSE_BRACE

    RETURN  décalage et aller à l'état 17
    PRINTF  décalage et aller à l'état 18
    CONST   décalage et aller à l'état 1
    IF      décalage et aller à l'état 19
    ELSE    décalage et aller à l'état 20
    WHILE   décalage et aller à l'état 21
    ALPHA   décalage et aller à l'état 12
    INT     décalage et aller à l'état 2

    $défaut  réduction par utilisation de la règle 4 (insts)

    insts        aller à l'état 22
    inst         aller à l'état 23
    declaration  aller à l'état 24
    affectation  aller à l'état 25
    print        aller à l'état 26
    ifBlock      aller à l'état 27
    whileBlock   aller à l'état 28
    type         aller à l'état 29
    name         aller à l'état 30


État 15

    1 main_structure: type MAIN OPEN_PARENT params CLOSE_PARENT body .

    $défaut  réduction par utilisation de la règle 1 (main_structure)


État 16

   12 params: type name COMMA . params

    CONST  décalage et aller à l'état 1
    INT    décalage et aller à l'état 2

    $défaut  réduction par utilisation de la règle 14 (params)

    params  aller à l'état 31
    type    aller à l'état 10


État 17

   10 inst: RETURN . value SEMICOLON
   11     | RETURN . name SEMICOLON

    NUMBER  décalage et aller à l'état 32
    ALPHA   décalage et aller à l'état 12

    value  aller à l'état 33
    name   aller à l'état 34


État 18

   18 print: PRINTF . OPEN_PARENT value CLOSE_PARENT SEMICOLON
   19      | PRINTF . OPEN_PARENT name CLOSE_PARENT SEMICOLON

    OPEN_PARENT  décalage et aller à l'état 35


État 19

   20 ifBlock: IF . OPEN_PARENT condition CLOSE_PARENT body

    OPEN_PARENT  décalage et aller à l'état 36


État 20

   21 ifBlock: ELSE . IF OPEN_PARENT condition CLOSE_PARENT body
   22        | ELSE . body

    OPEN_BRACE  décalage et aller à l'état 14
    IF          décalage et aller à l'état 37

    body  aller à l'état 38


État 21

   23 whileBlock: WHILE . OPEN_PARENT condition CLOSE_PARENT body

    OPEN_PARENT  décalage et aller à l'état 39


État 22

    2 body: OPEN_BRACE insts . CLOSE_BRACE

    CLOSE_BRACE  décalage et aller à l'état 40


État 23

    3 insts: inst . insts

    RETURN  décalage et aller à l'état 17
    PRINTF  décalage et aller à l'état 18
    CONST   décalage et aller à l'état 1
    IF      décalage et aller à l'état 19
    ELSE    décalage et aller à l'état 20
    WHILE   décalage et aller à l'état 21
    ALPHA   décalage et aller à l'état 12
    INT     décalage et aller à l'état 2

    $défaut  réduction par utilisation de la règle 4 (insts)

    insts        aller à l'état 41
    inst         aller à l'état 23
    declaration  aller à l'état 24
    affectation  aller à l'état 25
    print        aller à l'état 26
    ifBlock      aller à l'état 27
    whileBlock   aller à l'état 28
    type         aller à l'état 29
    name         aller à l'état 30


État 24

    5 inst: declaration .

    $défaut  réduction par utilisation de la règle 5 (inst)


État 25

    6 inst: affectation .

    $défaut  réduction par utilisation de la règle 6 (inst)


État 26

    7 inst: print .

    $défaut  réduction par utilisation de la règle 7 (inst)


État 27

    8 inst: ifBlock .

    $défaut  réduction par utilisation de la règle 8 (inst)


État 28

    9 inst: whileBlock .

    $défaut  réduction par utilisation de la règle 9 (inst)


État 29

   15 declaration: type . ids SEMICOLON
   16 affectation: type . id EQUAL value SEMICOLON

    ALPHA  décalage et aller à l'état 42

    id   aller à l'état 43
    ids  aller à l'état 44


État 30

   17 affectation: name . EQUAL value SEMICOLON

    EQUAL  décalage et aller à l'état 45


État 31

   12 params: type name COMMA params .

    $défaut  réduction par utilisation de la règle 12 (params)


État 32

   34 value: NUMBER .

    $défaut  réduction par utilisation de la règle 34 (value)


État 33

   10 inst: RETURN value . SEMICOLON

    SEMICOLON  décalage et aller à l'état 46


État 34

   11 inst: RETURN name . SEMICOLON

    SEMICOLON  décalage et aller à l'état 47


État 35

   18 print: PRINTF OPEN_PARENT . value CLOSE_PARENT SEMICOLON
   19      | PRINTF OPEN_PARENT . name CLOSE_PARENT SEMICOLON

    NUMBER  décalage et aller à l'état 32
    ALPHA   décalage et aller à l'état 12

    value  aller à l'état 48
    name   aller à l'état 49


État 36

   20 ifBlock: IF OPEN_PARENT . condition CLOSE_PARENT body

    EXCLAM  décalage et aller à l'état 50
    NUMBER  décalage et aller à l'état 32
    ALPHA   décalage et aller à l'état 12

    condition     aller à l'état 51
    unaryOperand  aller à l'état 52
    value         aller à l'état 53
    name          aller à l'état 54
    valueOrVar    aller à l'état 55


État 37

   21 ifBlock: ELSE IF . OPEN_PARENT condition CLOSE_PARENT body

    OPEN_PARENT  décalage et aller à l'état 56


État 38

   22 ifBlock: ELSE body .

    $défaut  réduction par utilisation de la règle 22 (ifBlock)


État 39

   23 whileBlock: WHILE OPEN_PARENT . condition CLOSE_PARENT body

    EXCLAM  décalage et aller à l'état 50
    NUMBER  décalage et aller à l'état 32
    ALPHA   décalage et aller à l'état 12

    condition     aller à l'état 57
    unaryOperand  aller à l'état 52
    value         aller à l'état 53
    name          aller à l'état 54
    valueOrVar    aller à l'état 55


État 40

    2 body: OPEN_BRACE insts CLOSE_BRACE .

    $défaut  réduction par utilisation de la règle 2 (body)


État 41

    3 insts: inst insts .

    $défaut  réduction par utilisation de la règle 3 (insts)


État 42

   40 id: ALPHA .

    $défaut  réduction par utilisation de la règle 40 (id)


État 43

   16 affectation: type id . EQUAL value SEMICOLON
   41 ids: id . COMMA ids
   42    | id .

    COMMA  décalage et aller à l'état 58
    EQUAL  décalage et aller à l'état 59

    $défaut  réduction par utilisation de la règle 42 (ids)


État 44

   15 declaration: type ids . SEMICOLON

    SEMICOLON  décalage et aller à l'état 60


État 45

   17 affectation: name EQUAL . value SEMICOLON

    NUMBER  décalage et aller à l'état 32

    value  aller à l'état 61


État 46

   10 inst: RETURN value SEMICOLON .

    $défaut  réduction par utilisation de la règle 10 (inst)


État 47

   11 inst: RETURN name SEMICOLON .

    $défaut  réduction par utilisation de la règle 11 (inst)


État 48

   18 print: PRINTF OPEN_PARENT value . CLOSE_PARENT SEMICOLON

    CLOSE_PARENT  décalage et aller à l'état 62


État 49

   19 print: PRINTF OPEN_PARENT name . CLOSE_PARENT SEMICOLON

    CLOSE_PARENT  décalage et aller à l'état 63


État 50

   33 unaryOperand: EXCLAM .

    $défaut  réduction par utilisation de la règle 33 (unaryOperand)


État 51

   20 ifBlock: IF OPEN_PARENT condition . CLOSE_PARENT body

    CLOSE_PARENT  décalage et aller à l'état 64


État 52

   25 condition: unaryOperand . valueOrVar

    NUMBER  décalage et aller à l'état 32
    ALPHA   décalage et aller à l'état 12

    value       aller à l'état 53
    name        aller à l'état 54
    valueOrVar  aller à l'état 65


État 53

   38 valueOrVar: value .

    $défaut  réduction par utilisation de la règle 38 (valueOrVar)


État 54

   39 valueOrVar: name .

    $défaut  réduction par utilisation de la règle 39 (valueOrVar)


État 55

   24 condition: valueOrVar .
   26          | valueOrVar . binaryOperand valueOrVar

    EQUALITY  décalage et aller à l'état 66
    DIFF      décalage et aller à l'état 67
    LESS      décalage et aller à l'état 68
    MORE      décalage et aller à l'état 69
    LESS_EQ   décalage et aller à l'état 70
    MORE_EQ   décalage et aller à l'état 71

    $défaut  réduction par utilisation de la règle 24 (condition)

    binaryOperand  aller à l'état 72


État 56

   21 ifBlock: ELSE IF OPEN_PARENT . condition CLOSE_PARENT body

    EXCLAM  décalage et aller à l'état 50
    NUMBER  décalage et aller à l'état 32
    ALPHA   décalage et aller à l'état 12

    condition     aller à l'état 73
    unaryOperand  aller à l'état 52
    value         aller à l'état 53
    name          aller à l'état 54
    valueOrVar    aller à l'état 55


État 57

   23 whileBlock: WHILE OPEN_PARENT condition . CLOSE_PARENT body

    CLOSE_PARENT  décalage et aller à l'état 74


État 58

   41 ids: id COMMA . ids

    ALPHA  décalage et aller à l'état 42

    id   aller à l'état 75
    ids  aller à l'état 76


État 59

   16 affectation: type id EQUAL . value SEMICOLON

    NUMBER  décalage et aller à l'état 32

    value  aller à l'état 77


État 60

   15 declaration: type ids SEMICOLON .

    $défaut  réduction par utilisation de la règle 15 (declaration)


État 61

   17 affectation: name EQUAL value . SEMICOLON

    SEMICOLON  décalage et aller à l'état 78


État 62

   18 print: PRINTF OPEN_PARENT value CLOSE_PARENT . SEMICOLON

    SEMICOLON  décalage et aller à l'état 79


État 63

   19 print: PRINTF OPEN_PARENT name CLOSE_PARENT . SEMICOLON

    SEMICOLON  décalage et aller à l'état 80


État 64

   20 ifBlock: IF OPEN_PARENT condition CLOSE_PARENT . body

    OPEN_BRACE  décalage et aller à l'état 14

    body  aller à l'état 81


État 65

   25 condition: unaryOperand valueOrVar .

    $défaut  réduction par utilisation de la règle 25 (condition)


État 66

   31 binaryOperand: EQUALITY .

    $défaut  réduction par utilisation de la règle 31 (binaryOperand)


État 67

   32 binaryOperand: DIFF .

    $défaut  réduction par utilisation de la règle 32 (binaryOperand)


État 68

   27 binaryOperand: LESS .

    $défaut  réduction par utilisation de la règle 27 (binaryOperand)


État 69

   29 binaryOperand: MORE .

    $défaut  réduction par utilisation de la règle 29 (binaryOperand)


État 70

   28 binaryOperand: LESS_EQ .

    $défaut  réduction par utilisation de la règle 28 (binaryOperand)


État 71

   30 binaryOperand: MORE_EQ .

    $défaut  réduction par utilisation de la règle 30 (binaryOperand)


État 72

   26 condition: valueOrVar binaryOperand . valueOrVar

    NUMBER  décalage et aller à l'état 32
    ALPHA   décalage et aller à l'état 12

    value       aller à l'état 53
    name        aller à l'état 54
    valueOrVar  aller à l'état 82


État 73

   21 ifBlock: ELSE IF OPEN_PARENT condition . CLOSE_PARENT body

    CLOSE_PARENT  décalage et aller à l'état 83


État 74

   23 whileBlock: WHILE OPEN_PARENT condition CLOSE_PARENT . body

    OPEN_BRACE  décalage et aller à l'état 14

    body  aller à l'état 84


État 75

   41 ids: id . COMMA ids
   42    | id .

    COMMA  décalage et aller à l'état 58

    $défaut  réduction par utilisation de la règle 42 (ids)


État 76

   41 ids: id COMMA ids .

    $défaut  réduction par utilisation de la règle 41 (ids)


État 77

   16 affectation: type id EQUAL value . SEMICOLON

    SEMICOLON  décalage et aller à l'état 85


État 78

   17 affectation: name EQUAL value SEMICOLON .

    $défaut  réduction par utilisation de la règle 17 (affectation)


État 79

   18 print: PRINTF OPEN_PARENT value CLOSE_PARENT SEMICOLON .

    $défaut  réduction par utilisation de la règle 18 (print)


État 80

   19 print: PRINTF OPEN_PARENT name CLOSE_PARENT SEMICOLON .

    $défaut  réduction par utilisation de la règle 19 (print)


État 81

   20 ifBlock: IF OPEN_PARENT condition CLOSE_PARENT body .

    $défaut  réduction par utilisation de la règle 20 (ifBlock)


État 82

   26 condition: valueOrVar binaryOperand valueOrVar .

    $défaut  réduction par utilisation de la règle 26 (condition)


État 83

   21 ifBlock: ELSE IF OPEN_PARENT condition CLOSE_PARENT . body

    OPEN_BRACE  décalage et aller à l'état 14

    body  aller à l'état 86


État 84

   23 whileBlock: WHILE OPEN_PARENT condition CLOSE_PARENT body .

    $défaut  réduction par utilisation de la règle 23 (whileBlock)


État 85

   16 affectation: type id EQUAL value SEMICOLON .

    $défaut  réduction par utilisation de la règle 16 (affectation)


État 86

   21 ifBlock: ELSE IF OPEN_PARENT condition CLOSE_PARENT body .

    $défaut  réduction par utilisation de la règle 21 (ifBlock)
